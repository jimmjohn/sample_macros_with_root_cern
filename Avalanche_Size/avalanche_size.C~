#include <iostream>
#include <fstream>
#include <iomanip>
#include <vector>
#include <cmath>
#include <TMath.h>
#include "TF1.h"
#include "TH1F.h"
#include "TGraph.h"
#include "TCanvas.h"
#include "TMinuit.h"
#include "TLatex.h"
#include "TGraphErrors.h"
#include "TLegend.h"
#include <TStyle.h>
#include <TGraph2D.h>
#include <TRandom1.h>
#include <TF2.h>
#include <TH1.h>
#include <tgmath.h>
#include "TFile.h"

using namespace std;

int main()
{

  //Value of alpha eta and k
  const double alpha = 13.3;
  const double eta = 3.5;
  const double k = eta/alpha;

  // open a new ROOT file
  TFile *f = TFile::Open("Avalanche_Size.root", "RECREATE");

  TGraph* avlan_size = new TGraph();

  int i=0;

  double n1=1;
  
  for(double x=0; x<2.0; x=x+0.0002) {

    double n2=0;
    
    for(double eleNo=0;eleNo<n1;eleNo++) {

      TRandom1 *r3 = new TRandom1();
      double s3 = r3->Uniform(0,1);
      int selector=0;
      if(s3<1.0/3.0){selector=0;}
      if(s3<2.0/3.0 && s3>=1.0/3.0){selector=1;}
      if(s3>2.0/3.0){selector=2;}
      
      double nBar = exp((alpha-eta)*x);

      double n15=0;
      double n16=0;
      double n17=0;

      switch(selector) {
      case 0:
	//Generating Equation 7=>15
	TRandom1 *r15 = new TRandom1();
	double s15 = r15->Uniform(0,1);
	//cout<<"Number15="<<s15<<endl;
	double limit15 = k*(nBar-1)/(nBar-k);
	if(s15<limit15) {
	  n15 = 0;
	  //avlan_size->SetPoint(i,x,n15);
	  //cout<<"n15="<<n15<<endl;
	}
	if(s15>limit15) {
	  n15 = 1.0 + (int)(log((nBar-k)*(1-s15)/(nBar*(1-k)))/log(1.0-((1-k)/(nBar-k))));
	  avlan_size->SetPoint(i,x,n15);
	  //cout<<"n15="<<n15<<endl;
	}
	n2 = n2 + n15;
	break;
	
      case 1:
	//Generating Equation 11=>16
	TRandom1 *r16 = new TRandom1();
	double s16 = r16->Uniform(0,1);
	//cout<<"Number16="<<s16<<endl;
	double limit16 = (alpha*x)/(1.0+(alpha*x));
	if(s16<limit16) {
	  n16 = 0;
	  //cout<<"n16="<<n16<<endl;
	}
	if(s16>limit16) {
	  n16 = 1.0 + (int)(log((1.0-s16)*(1.0+(alpha*x)))/log((alpha*x)/(1.0+(alpha*x))));
	  //cout<<"n16="<<n16<<endl;
	}
	n2 = n2 + n16;
	break;
	
      case 2:
	//Generating Equation 13=>17
	TRandom1 *r17 = new TRandom1();
	double s17 = r17->Uniform(0,1);
	//cout<<"Number17="<<s17<<endl;
	double limit17 = exp(-1.0*eta*x);
	if(s17>limit17) {
	  n17 = 0;
	  //cout<<"n17="<<n17<<endl;
	}
	if(s17<limit17) {
	  n17 = 1.0;
	  //cout<<"n17="<<n17<<endl;
	}
	n2 = n2 + n17;
	break;
      } // switch case ending
    }//eleNo loop ending
    n1 = n2;
    i++;
  }//x loop ending

  TCanvas *c1 = new TCanvas("c1", "canvas",1000,2000);
  c1->cd();
  c1->Divide(2,2,0,0);
  gStyle->SetOptFit(1111);
  c1->cd(1);
  gPad->SetLeftMargin(0.15);
  gPad->SetRightMargin(0.15);
  gPad->SetTopMargin(0.15);
  gPad->SetBottomMargin(0.15);
  avlan_size->Draw("AP");


  f->cd();
  avlan_size->Write("Avalanche_Size");


























































  // unsigned int i;
  // double x,normalization;
  // TCanvas *c1 = new TCanvas("c1", "canvas",1000,2000);
  // c1->cd();
  // c1->Divide(2,2,0,0);
  // gStyle->SetOptFit(1111);

  // // The theta distribution for spherically symmetric disribution
  // c1->cd(1);
  // gPad->SetLeftMargin(0.15);
  // gPad->SetRightMargin(0.15);
  // gPad->SetTopMargin(0.15);
  // gPad->SetBottomMargin(0.15);
  // double theta,f_theta;
  // auto fun1 = new TH1D("fun1","Theta Distribution",1000,0,3.14);
  // for(i=0;i<1000000;i++)
  //   {
  //     x=((double) rand() / (RAND_MAX));
  //     theta=acos(1.0-2.0*x);
  //     fun1->Fill(theta);
  //   }
  // normalization = fun1->GetEntries();
  // fun1->Scale(1/normalization);
  // TF1  *f1 = new TF1("f1","[0]*sin(x)",0,1);
  // f1->SetParameter(0,400);
  // fun1->Fit(f1);
  // fun1->Draw("");


  // // The exponential distribution (let tau=10)
  // c1->cd(2);
  // gPad->SetLogy();
  // gPad->SetLeftMargin(0.15);
  // gPad->SetRightMargin(0.15);
  // gPad->SetTopMargin(0.15);
  // gPad->SetBottomMargin(0.15);
  // double tau=0.5,t;
  // auto fun2 = new TH1D("fun2","Exponential Distribution",10000,-10,0);
  // for(i=0;i<1000000;i++)
  //   {
  //     x=(double) rand();
  //     t=-1.0*tau*log(x);
  //     fun2->Fill(t);
  //   }
  // normalization = fun2->GetEntries();
  // fun2->Scale(1/normalization);
  // TF1  *f2 = new TF1("f2","[0]*exp(-x/[1])/[1]",-10,0);
  // f2->SetParameters(400,0.5);
  // fun2->Fit(f2);
  // fun2->Draw("");

  // // The cosmic spectra
  // c1->cd(3);
  // gPad->SetLogy();
  // gPad->SetLeftMargin(0.15);
  // gPad->SetRightMargin(0.15);
  // gPad->SetTopMargin(0.15);
  // gPad->SetBottomMargin(0.15);
  // double norm,alpha,elow,ehigh,e;
  // elow=1000;
  // ehigh=1000000.0;
  // alpha=3.0;
  // norm=(1.0-alpha)/(pow(ehigh,1.0-alpha)-pow(elow,1.0-alpha));
  // auto fun3 = new TH1D("fun3","Cosmic Spectra",10000,1000,10000);
  // for(i=0;i<1000000;i++)
  //   {
  //     x=((double) rand() / (RAND_MAX));
  //     e=pow(elow,1.0-alpha)-((alpha-1.0)*x/norm);
  //     e=pow(e,-1.0/(alpha-1.0));
  //     fun3->Fill(e);
  //   }
  // normalization = fun3->GetEntries();
  // fun3->Scale(1/normalization);
  // TF1  *f3 = new TF1("f3","[0]*pow(x,-3.0)",1000,10000);
  // f3->SetParameter(0,1000);
  // fun3->Fit(f3);
  // fun3->Draw("");

  // // The Gaussian Transformation
  // c1->cd(4);
  // gPad->SetLeftMargin(0.15);
  // gPad->SetRightMargin(0.15);
  // gPad->SetTopMargin(0.15);
  // gPad->SetBottomMargin(0.15);
  // double x1,x2,y1,y2;
  // auto fun4 = new TH1D("fun4","Box Muller Transformation",10000,-10,10);
  // for(i=0;i<1000000;i++)
  //   {
  //     x1=((double) rand() / (RAND_MAX));
  //     x2=((double) rand() / (RAND_MAX));
  //     y1=sqrt(-2.0*log(x1))*cos(2.0*3.14*x2);
  //     y2=sqrt(-2.0*log(x1))*sin(2.0*3.14*x2);
  //     fun4->Fill(y2);
  //   }
  // normalization = fun4->GetEntries();
  // fun4->Scale(1/normalization);
  // TF1  *f4 = new TF1("f4","[0]*exp(-0.5*pow(x,2))",-10,10);
  // f4->SetParameter(0,10);
  // fun4->Fit(f4);
  // fun4->Draw("");

  return 0;

}
